// class Solution {
//     public long maximumTotalDamage(int[] arr) {
//         Arrays.sort(arr);
//         int n=arr.length;
//         int dp[]=new int[n];
//         int ans=0;
//         for(int i=0;i<n;i++){
//             dp[i]=arr[i];
//             for(int j=i-1;j>=0;j--){
              
//                 if(arr[i]==arr[j] || arr[j]<arr[i]-2)dp[i]=Math.max(dp[i],dp[j]+arr[i]);
//             }
//             ans=Math.max(ans,dp[i]);
//         }
//         return ans;
//     }
// }


class Solution {
    // HashMap<Integer,ArrayList<Integer>>map=new HashMap<>();
    HashMap<Integer,Integer>map=new HashMap<>();
    long dp[];
    int getNextIndex(long x,int arr[]){
        int l=0,r=arr.length-1;
        while(l<=r){
            int mid=(l+r)>>1;
            if(arr[mid]<=x)l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    long solve(int i,int arr[],HashMap<Integer,Integer>map){
        if(i>=arr.length)return 0;
        if(dp[i]!=-1)return dp[i];
        long pick=0;
        int ind=getNextIndex(arr[i]+2,arr);
        long val=(long)arr[i]*map.get(arr[i]);
        pick=solve(ind,arr,map)+val;
         long notPick=0;
        notPick=solve(i+1,arr,map);
        
        return dp[i]=Math.max(notPick,pick);

    }
    public long maximumTotalDamage(int[] arr) {
        int n=arr.length;
        Arrays.sort(arr);
        dp=new long[n+1];
        Arrays.fill(dp,-1);
        for(int it : arr)map.put(it,map.getOrDefault(it,0)+1);
        // for(int i=0;i<n;i++){
        //     if(map.containsKey(arr[i])==false)map.put(arr[i],new ArrayList<>());
        //     else{
        //         int prev=map.get(arr[i]).get(map.get(arr[i]).size()-1);
        //         if(arr[prev]+2>=arr[i] && arr[prev]!=arr[i])continue;
        //     }
        //     map.get(arr[i]).add(i);
        // }
       
        return solve(0,arr,map);
    }
}
