class Solution {
    int dp[][]=new int[201][201];
    int solve(int grid[][],int n,int m){
        // if(n==0)return grid[n][m];
        // int ans=10000;
        // if(dp[n][m]!=-1)return dp[n][m];
        // for(int i=0;i<grid[0].length;i++){
        //     if(i==m)continue;
        //     int temp=solve(grid,n-1,i)+grid[n][m];
        //     ans=Math.min(temp,ans);
        // }
        
// return dp[n][m]=ans;//you can add grid[n][m]here
        int prev[]=new int[200+1];
        int curr[]=new int[200+1];
        for(int i=0;i<=n;i++){
            curr=new int[200+1];
            for(int j=0;j<grid[0].length;j++){
                if(i==0)curr[j]=grid[i][j];
                else {
                    int ans=Integer.MAX_VALUE;
                    for(int k=0;k<grid[0].length;k++){
                        if(k==j)continue;
                        int temp=prev[k]+grid[i][j];
                        ans=Math.min(temp,ans);
                    }
                    curr[j]=ans;
                }

            }
            prev=curr;
        }
        int ans=Integer.MAX_VALUE;
        for(int i=0;i<=n;i++){
            // System.out.print(grid[n][i]);
            ans=Math.min(ans,curr[i]);
        }
        return ans;
    }
    public int minFallingPathSum(int[][] grid) {
        int ans=Integer.MAX_VALUE;

        // for(int i=0;i<grid[0].length;i++)
        // {   
        //     // for(int j=0;j<201;j++){
        //     //     for(int k=0;k<201;k++){
        //     //         dp[j][k]=-1;
        //     //     }
        //     // }
            
            ans=Math.min(ans,solve(grid,grid.length-1,0));
        // }
        return ans;
    }
}
